// Diesel schema generation — creates Diesel-compatible schema macros and migration SQL.
//
// Generates `diesel::table!` macros, `up.sql`, and `down.sql` migration files
// from the core AuthSchema definition.

use better_auth_core::db::schema::{AuthSchema, FieldType, SchemaField};

/// Generate the Diesel `table!` macro invocations for every table in the schema.
///
/// Produces code like:
/// ```ignore
/// diesel::table! {
///     user (id) {
///         id -> Text,
///         name -> Text,
///         email -> Text,
///         ...
///     }
/// }
/// ```
pub fn generate_diesel_tables(schema: &AuthSchema) -> String {
    let mut output = String::new();
    output.push_str("// Auto-generated by better-auth-diesel\n");
    output.push_str("// Do not edit this file manually.\n\n");

    for (table_name, table) in &schema.tables {
        output.push_str(&format!("diesel::table! {{\n    {} (id) {{\n", table_name));

        for (field_name, field) in &table.fields {
            let diesel_type = field_type_to_diesel(&field.field_type, field.required);
            output.push_str(&format!("        {} -> {},\n", field_name, diesel_type));
        }

        output.push_str("    }\n}\n\n");
    }

    // Generate joinable! macros for foreign keys
    for (table_name, table) in &schema.tables {
        for (_, field) in &table.fields {
            if let Some(ref reference) = field.references {
                output.push_str(&format!(
                    "diesel::joinable!({} -> {} ({}));\n",
                    table_name, reference.model, reference.field
                ));
            }
        }
    }

    if !schema.tables.is_empty() {
        output.push_str("\ndiesel::allow_tables_to_appear_in_same_query!(\n");
        let table_names: Vec<&String> = schema.tables.keys().collect();
        for (i, name) in table_names.iter().enumerate() {
            if i < table_names.len() - 1 {
                output.push_str(&format!("    {},\n", name));
            } else {
                output.push_str(&format!("    {},\n", name));
            }
        }
        output.push_str(");\n");
    }

    output
}

/// Generate SQL `CREATE TABLE` statements for Diesel migrations (`up.sql`).
pub fn generate_up_sql(schema: &AuthSchema, dialect: &str) -> String {
    let mut sql = String::new();
    sql.push_str("-- Auto-generated by better-auth-diesel\n");
    sql.push_str("-- Migration: up.sql\n\n");

    for (table_name, table) in &schema.tables {
        let q = if dialect == "mysql" { "`" } else { "\"" };
        sql.push_str(&format!(
            "CREATE TABLE IF NOT EXISTS {q}{}{q} (\n",
            table_name
        ));

        let field_count = table.fields.len();
        let mut fk_constraints = Vec::new();

        for (i, (field_name, field)) in table.fields.iter().enumerate() {
            let col_type = field_type_to_sql(&field.field_type, dialect);
            let mut col_def = format!("    {q}{}{q} {}", field_name, col_type);

            if field_name == "id" {
                col_def.push_str(" PRIMARY KEY");
            }

            if !field.required && field_name != "id" {
                // nullable — no NOT NULL
            } else if field_name != "id" {
                col_def.push_str(" NOT NULL");
            }

            if field.unique {
                col_def.push_str(" UNIQUE");
            }

            if let Some(ref default) = field.default_value {
                col_def.push_str(&format!(" DEFAULT {}", format_sql_default(default)));
            }

            if let Some(ref reference) = field.references {
                fk_constraints.push(format!(
                    "    FOREIGN KEY ({q}{}{q}) REFERENCES {q}{}{q}({q}{}{q}) ON DELETE CASCADE",
                    field_name, reference.model, reference.field
                ));
            }

            if i < field_count - 1 || !fk_constraints.is_empty() {
                col_def.push(',');
            }
            sql.push_str(&col_def);
            sql.push('\n');
        }

        for (i, fk) in fk_constraints.iter().enumerate() {
            if i < fk_constraints.len() - 1 {
                sql.push_str(&format!("{},\n", fk));
            } else {
                sql.push_str(&format!("{}\n", fk));
            }
        }

        sql.push_str(");\n\n");
    }

    sql
}

/// Generate SQL `DROP TABLE` statements for Diesel migrations (`down.sql`).
pub fn generate_down_sql(schema: &AuthSchema, dialect: &str) -> String {
    let mut sql = String::new();
    sql.push_str("-- Auto-generated by better-auth-diesel\n");
    sql.push_str("-- Migration: down.sql\n\n");

    let q = if dialect == "mysql" { "`" } else { "\"" };

    // Drop in reverse order to handle FK dependencies
    let table_names: Vec<&String> = schema.tables.keys().collect();
    for name in table_names.iter().rev() {
        sql.push_str(&format!(
            "DROP TABLE IF EXISTS {q}{}{q};\n",
            name
        ));
    }

    sql
}

/// Map FieldType to Diesel type expression.
fn field_type_to_diesel(field_type: &FieldType, required: bool) -> String {
    let base = match field_type {
        FieldType::String => "Text",
        FieldType::Number => "Integer",
        FieldType::Boolean => "Bool",
        FieldType::Date => "Timestamp",
    };

    if required {
        base.to_string()
    } else {
        format!("Nullable<{}>", base)
    }
}

/// Map FieldType to SQL column type.
fn field_type_to_sql(field_type: &FieldType, dialect: &str) -> &'static str {
    match (field_type, dialect) {
        (FieldType::String, "postgres") => "TEXT",
        (FieldType::String, "mysql") => "VARCHAR(255)",
        (FieldType::String, _) => "TEXT",
        (FieldType::Number, "postgres") => "INTEGER",
        (FieldType::Number, "mysql") => "INT",
        (FieldType::Number, _) => "INTEGER",
        (FieldType::Boolean, "postgres") => "BOOLEAN",
        (FieldType::Boolean, "mysql") => "TINYINT(1)",
        (FieldType::Boolean, _) => "BOOLEAN",
        (FieldType::Date, "postgres") => "TIMESTAMP WITH TIME ZONE",
        (FieldType::Date, "mysql") => "DATETIME",
        (FieldType::Date, _) => "TIMESTAMP",
    }
}

/// Format a default value for SQL.
fn format_sql_default(value: &serde_json::Value) -> String {
    match value {
        serde_json::Value::String(s) => format!("'{}'", s.replace('\'', "''")),
        serde_json::Value::Number(n) => n.to_string(),
        serde_json::Value::Bool(b) => {
            if *b {
                "TRUE".to_string()
            } else {
                "FALSE".to_string()
            }
        }
        _ => "NULL".to_string(),
    }
}

/// Generate Diesel schema.rs and migration files as a tuple: (schema_rs, up_sql, down_sql).
pub fn generate_all(schema: &AuthSchema, dialect: &str) -> (String, String, String) {
    (
        generate_diesel_tables(schema),
        generate_up_sql(schema, dialect),
        generate_down_sql(schema, dialect),
    )
}

#[cfg(test)]
mod tests {
    use super::*;
    use better_auth_core::db::schema::AuthSchema;

    #[test]
    fn test_generate_diesel_tables() {
        let schema = AuthSchema::core_schema();
        let output = generate_diesel_tables(&schema);
        assert!(output.contains("diesel::table!"));
        assert!(output.contains("id -> Text"));
    }

    #[test]
    fn test_generate_up_sql_sqlite() {
        let schema = AuthSchema::core_schema();
        let sql = generate_up_sql(&schema, "sqlite");
        assert!(sql.contains("CREATE TABLE IF NOT EXISTS"));
        assert!(sql.contains("PRIMARY KEY"));
    }

    #[test]
    fn test_generate_up_sql_postgres() {
        let schema = AuthSchema::core_schema();
        let sql = generate_up_sql(&schema, "postgres");
        assert!(sql.contains("TIMESTAMP WITH TIME ZONE"));
    }

    #[test]
    fn test_generate_up_sql_mysql() {
        let schema = AuthSchema::core_schema();
        let sql = generate_up_sql(&schema, "mysql");
        assert!(sql.contains("VARCHAR(255)"));
        assert!(sql.contains("DATETIME"));
    }

    #[test]
    fn test_generate_down_sql() {
        let schema = AuthSchema::core_schema();
        let sql = generate_down_sql(&schema, "sqlite");
        assert!(sql.contains("DROP TABLE IF EXISTS"));
    }

    #[test]
    fn test_field_type_to_diesel() {
        assert_eq!(field_type_to_diesel(&FieldType::String, true), "Text");
        assert_eq!(field_type_to_diesel(&FieldType::String, false), "Nullable<Text>");
        assert_eq!(field_type_to_diesel(&FieldType::Number, true), "Integer");
        assert_eq!(field_type_to_diesel(&FieldType::Boolean, true), "Bool");
        assert_eq!(field_type_to_diesel(&FieldType::Date, true), "Timestamp");
    }

    #[test]
    fn test_generate_all() {
        let schema = AuthSchema::core_schema();
        let (schema_rs, up, down) = generate_all(&schema, "sqlite");
        assert!(!schema_rs.is_empty());
        assert!(!up.is_empty());
        assert!(!down.is_empty());
    }
}
