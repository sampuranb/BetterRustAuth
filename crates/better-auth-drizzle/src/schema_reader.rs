// Schema reader — reads Drizzle schema files to extract table/column definitions.
//
// When migrating from the TypeScript version, users may have existing Drizzle schema files
// (e.g., `schema.ts`). This module can read SQL migration files generated by Drizzle
// to validate compatibility with the Rust adapter.

use std::collections::HashMap;
use std::path::Path;

/// Represents a column definition extracted from a Drizzle schema.
#[derive(Debug, Clone)]
pub struct DrizzleColumn {
    /// Column name (as it appears in the database).
    pub name: String,
    /// SQL type (e.g., "text", "integer", "boolean", "timestamp").
    pub sql_type: String,
    /// Whether the column is nullable.
    pub nullable: bool,
    /// Whether this is a primary key.
    pub primary_key: bool,
    /// Default value expression, if any.
    pub default: Option<String>,
}

/// Represents a table definition extracted from a Drizzle schema.
#[derive(Debug, Clone)]
pub struct DrizzleTable {
    /// Table name in the database.
    pub name: String,
    /// Column definitions.
    pub columns: Vec<DrizzleColumn>,
}

/// Result of reading a Drizzle migration directory.
#[derive(Debug, Clone)]
pub struct DrizzleMigrationSet {
    /// SQL statements from migration files, in order.
    pub statements: Vec<String>,
    /// Table definitions extracted from CREATE TABLE statements.
    pub tables: HashMap<String, DrizzleTable>,
}

/// Read SQL migration files from a Drizzle migration directory.
///
/// Drizzle generates migration files in a `drizzle/` or `migrations/` directory,
/// each containing SQL statements. This function reads them in alphabetical
/// order (Drizzle uses timestamp-based naming) and extracts table definitions.
///
/// # Arguments
/// * `migration_dir` — Path to the Drizzle migration directory (e.g., `./drizzle`)
///
/// # Returns
/// A `DrizzleMigrationSet` with all SQL statements and extracted table definitions.
pub fn read_migrations(migration_dir: &Path) -> Result<DrizzleMigrationSet, String> {
    let mut statements = Vec::new();
    let mut tables = HashMap::new();

    if !migration_dir.exists() {
        return Err(format!(
            "Drizzle migration directory not found: {}",
            migration_dir.display()
        ));
    }

    // Collect and sort SQL files
    let mut sql_files: Vec<_> = std::fs::read_dir(migration_dir)
        .map_err(|e| format!("Failed to read migration directory: {e}"))?
        .filter_map(|entry| entry.ok())
        .filter(|entry| {
            entry.path().extension().and_then(|ext| ext.to_str()) == Some("sql")
        })
        .collect();

    sql_files.sort_by_key(|entry| entry.file_name());

    for entry in sql_files {
        let content = std::fs::read_to_string(entry.path())
            .map_err(|e| format!("Failed to read migration file {:?}: {e}", entry.path()))?;

        // Parse CREATE TABLE statements
        for table in parse_create_tables(&content) {
            tables.insert(table.name.clone(), table);
        }

        statements.push(content);
    }

    Ok(DrizzleMigrationSet { statements, tables })
}

/// Parse CREATE TABLE statements from SQL content.
fn parse_create_tables(sql: &str) -> Vec<DrizzleTable> {
    let mut tables = Vec::new();
    let upper = sql.to_uppercase();
    let mut pos = 0;

    while let Some(start) = upper[pos..].find("CREATE TABLE") {
        let abs_start = pos + start;
        let table_sql = &sql[abs_start..];

        // Find the table name (after CREATE TABLE [IF NOT EXISTS])
        let after_create = &table_sql["CREATE TABLE".len()..].trim_start();
        let name_start = if after_create
            .to_uppercase()
            .starts_with("IF NOT EXISTS")
        {
            after_create["IF NOT EXISTS".len()..].trim_start()
        } else {
            after_create
        };

        // Extract table name (handle quoted and unquoted)
        let table_name = extract_identifier(name_start);

        // Find the closing parenthesis for the column definitions
        if let Some(paren_start) = table_sql.find('(') {
            if let Some(paren_end) = find_matching_paren(table_sql, paren_start) {
                let columns_sql = &table_sql[paren_start + 1..paren_end];
                let columns = parse_columns(columns_sql);

                tables.push(DrizzleTable {
                    name: table_name,
                    columns,
                });

                pos = abs_start + paren_end + 1;
                continue;
            }
        }

        pos = abs_start + "CREATE TABLE".len();
    }

    tables
}

/// Extract an identifier (table name, column name) handling various quoting styles.
fn extract_identifier(s: &str) -> String {
    let s = s.trim();
    if s.starts_with('"') {
        // Double-quoted identifier
        if let Some(end) = s[1..].find('"') {
            return s[1..1 + end].to_string();
        }
    } else if s.starts_with('`') {
        // Backtick-quoted identifier
        if let Some(end) = s[1..].find('`') {
            return s[1..1 + end].to_string();
        }
    } else if s.starts_with('[') {
        // Bracket-quoted identifier (SQL Server)
        if let Some(end) = s[1..].find(']') {
            return s[1..1 + end].to_string();
        }
    }

    // Unquoted — take until whitespace or parenthesis
    s.split(|c: char| c.is_whitespace() || c == '(' || c == ')')
        .next()
        .unwrap_or("")
        .to_string()
}

/// Find the matching closing parenthesis, handling nesting.
fn find_matching_paren(s: &str, open_pos: usize) -> Option<usize> {
    let mut depth = 0;
    for (i, ch) in s[open_pos..].chars().enumerate() {
        match ch {
            '(' => depth += 1,
            ')' => {
                depth -= 1;
                if depth == 0 {
                    return Some(open_pos + i);
                }
            }
            _ => {}
        }
    }
    None
}

/// Parse column definitions from the contents between CREATE TABLE parentheses.
fn parse_columns(columns_sql: &str) -> Vec<DrizzleColumn> {
    let mut columns = Vec::new();

    for line in columns_sql.split(',') {
        let line = line.trim();
        if line.is_empty() {
            continue;
        }

        // Skip constraints (PRIMARY KEY, FOREIGN KEY, UNIQUE, CHECK, INDEX)
        let upper = line.to_uppercase();
        if upper.starts_with("PRIMARY KEY")
            || upper.starts_with("FOREIGN KEY")
            || upper.starts_with("UNIQUE")
            || upper.starts_with("CHECK")
            || upper.starts_with("INDEX")
            || upper.starts_with("CONSTRAINT")
        {
            continue;
        }

        let name = extract_identifier(line);
        if name.is_empty() {
            continue;
        }

        // Get the rest after the column name
        let rest = line[line.find(&name).unwrap_or(0) + name.len()..].trim();
        let rest = if rest.starts_with('"') || rest.starts_with('`') || rest.starts_with('[') {
            // Skip past the closing quote
            &rest[1 + rest[1..].find(|c: char| c == '"' || c == '`' || c == ']').unwrap_or(0) + 1..]
        } else {
            rest
        };

        let sql_type = rest
            .split_whitespace()
            .next()
            .unwrap_or("text")
            .to_lowercase();

        let upper_rest = rest.to_uppercase();
        let nullable = !upper_rest.contains("NOT NULL");
        let primary_key =
            upper_rest.contains("PRIMARY KEY") || upper_rest.contains("PRIMARY");

        let default = if let Some(idx) = upper_rest.find("DEFAULT") {
            let after_default = rest[idx + "DEFAULT".len()..].trim();
            let default_val = after_default
                .split(|c: char| c == ',' || c.is_whitespace())
                .next()
                .unwrap_or("");
            if default_val.is_empty() {
                None
            } else {
                Some(default_val.to_string())
            }
        } else {
            None
        };

        columns.push(DrizzleColumn {
            name,
            sql_type,
            nullable,
            primary_key,
            default,
        });
    }

    columns
}

/// Validate that a Drizzle schema is compatible with the better-auth expected schema.
///
/// Checks that required tables (user, session, account, verification) exist
/// with the expected columns.
pub fn validate_compatibility(tables: &HashMap<String, DrizzleTable>) -> Vec<String> {
    let mut warnings = Vec::new();

    let required_tables = ["user", "session", "account", "verification"];
    for table in &required_tables {
        if !tables.contains_key(*table) && !tables.contains_key(&format!("{table}s")) {
            warnings.push(format!(
                "Required table '{}' not found in Drizzle schema (also checked '{}')",
                table,
                format!("{table}s")
            ));
        }
    }

    // Check user table has required columns
    let user_table = tables.get("user").or_else(|| tables.get("users"));
    if let Some(user) = user_table {
        let required_cols = ["id", "email", "name"];
        for col in &required_cols {
            if !user.columns.iter().any(|c| c.name == *col) {
                warnings.push(format!(
                    "User table missing required column: '{col}'"
                ));
            }
        }
    }

    // Check session table has required columns
    let session_table = tables.get("session").or_else(|| tables.get("sessions"));
    if let Some(session) = session_table {
        let required_cols = ["id", "token"];
        for col in &required_cols {
            if !session.columns.iter().any(|c| c.name == *col) {
                warnings.push(format!(
                    "Session table missing required column: '{col}'"
                ));
            }
        }
    }

    warnings
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_create_table() {
        let sql = r#"
            CREATE TABLE "user" (
                "id" text PRIMARY KEY NOT NULL,
                "email" text NOT NULL,
                "name" text,
                "created_at" timestamp DEFAULT CURRENT_TIMESTAMP
            );
        "#;

        let tables = parse_create_tables(sql);
        assert_eq!(tables.len(), 1);
        assert_eq!(tables[0].name, "user");
        assert_eq!(tables[0].columns.len(), 4);
        assert_eq!(tables[0].columns[0].name, "id");
        assert!(tables[0].columns[0].primary_key);
        assert!(!tables[0].columns[0].nullable);
    }

    #[test]
    fn test_parse_multiple_tables() {
        let sql = r#"
            CREATE TABLE "user" (
                "id" text PRIMARY KEY NOT NULL,
                "email" text NOT NULL
            );
            CREATE TABLE "session" (
                "id" text PRIMARY KEY NOT NULL,
                "token" text NOT NULL,
                "user_id" text NOT NULL
            );
        "#;

        let tables = parse_create_tables(sql);
        assert_eq!(tables.len(), 2);
        assert_eq!(tables[0].name, "user");
        assert_eq!(tables[1].name, "session");
    }

    #[test]
    fn test_validate_compatibility() {
        let mut tables = HashMap::new();
        tables.insert(
            "user".to_string(),
            DrizzleTable {
                name: "user".to_string(),
                columns: vec![
                    DrizzleColumn {
                        name: "id".to_string(),
                        sql_type: "text".to_string(),
                        nullable: false,
                        primary_key: true,
                        default: None,
                    },
                    DrizzleColumn {
                        name: "email".to_string(),
                        sql_type: "text".to_string(),
                        nullable: false,
                        primary_key: false,
                        default: None,
                    },
                    DrizzleColumn {
                        name: "name".to_string(),
                        sql_type: "text".to_string(),
                        nullable: true,
                        primary_key: false,
                        default: None,
                    },
                ],
            },
        );

        let warnings = validate_compatibility(&tables);
        // Should warn about missing tables: session, account, verification
        assert!(warnings.len() >= 3);
    }

    #[test]
    fn test_extract_identifier() {
        assert_eq!(extract_identifier("\"user\""), "user");
        assert_eq!(extract_identifier("`session`"), "session");
        assert_eq!(extract_identifier("[account]"), "account");
        assert_eq!(extract_identifier("user ("), "user");
    }
}
