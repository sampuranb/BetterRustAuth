// Sea-ORM entity generator — generates Sea-ORM entity files from AuthSchema.

use better_auth_core::db::schema::{AuthSchema, FieldType};

/// Generate Sea-ORM entity module code for a given schema.
///
/// Produces a `mod.rs` and per-table entity files.
pub fn generate_entities(schema: &AuthSchema) -> Vec<(String, String)> {
    let mut files = Vec::new();

    // mod.rs — re-export all entities
    let mut mod_rs = String::new();
    mod_rs.push_str("// Auto-generated by better-auth-sea-orm\n");
    mod_rs.push_str("// Do not edit this file manually.\n\n");

    for table_name in schema.tables.keys() {
        mod_rs.push_str(&format!("pub mod {};\n", table_name));
    }

    files.push(("mod.rs".to_string(), mod_rs));

    // Per-table entity files
    for (table_name, table) in &schema.tables {
        let mut entity = String::new();
        entity.push_str("// Auto-generated by better-auth-sea-orm\n");
        entity.push_str("use sea_orm::entity::prelude::*;\n\n");

        // Model struct
        entity.push_str("#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n");
        entity.push_str(&format!("#[sea_orm(table_name = \"{}\")]\n", table_name));
        entity.push_str("pub struct Model {\n");

        for (field_name, field) in &table.fields {
            let mut attrs = Vec::new();
            if field_name == "id" {
                attrs.push("primary_key".to_string());
                attrs.push("auto_increment = false".to_string());
            }
            if field.unique {
                attrs.push("unique".to_string());
            }

            if !attrs.is_empty() {
                entity.push_str(&format!("    #[sea_orm({})]\n", attrs.join(", ")));
            }

            let rust_type = field_type_to_rust(&field.field_type, field.required);
            entity.push_str(&format!("    pub {}: {},\n", field_name, rust_type));
        }

        entity.push_str("}\n\n");

        // Relations enum
        entity.push_str("#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\n");
        entity.push_str("pub enum Relation {\n");

        let mut has_relations = false;
        for (field_name, field) in &table.fields {
            if let Some(ref reference) = field.references {
                has_relations = true;
                let related_model = capitalize(&reference.model);
                entity.push_str(&format!(
                    "    #[sea_orm(\n        belongs_to = \"super::{}::Entity\",\n        from = \"Column::{}\",\n        to = \"super::{}::Column::{}\"\n    )]\n",
                    reference.model,
                    capitalize(field_name),
                    reference.model,
                    capitalize(&reference.field)
                ));
                entity.push_str(&format!("    {},\n", related_model));
            }
        }

        if !has_relations {
            // Empty relation enum body
        }

        entity.push_str("}\n\n");

        // Implement Related for each FK relation
        for (_, field) in &table.fields {
            if let Some(ref reference) = field.references {
                entity.push_str(&format!(
                    "impl Related<super::{}::Entity> for Entity {{\n",
                    reference.model
                ));
                entity.push_str(&format!(
                    "    fn to() -> RelationDef {{\n        Relation::{}.def()\n    }}\n",
                    capitalize(&reference.model)
                ));
                entity.push_str("}\n\n");
            }
        }

        // ActiveModelBehavior
        entity.push_str("impl ActiveModelBehavior for ActiveModel {}\n");

        files.push((format!("{}.rs", table_name), entity));
    }

    files
}

/// Generate a single entity file as a string for display/testing.
pub fn generate_all(schema: &AuthSchema) -> String {
    let entities = generate_entities(schema);
    let mut output = String::new();
    for (filename, content) in entities {
        output.push_str(&format!("// === {} ===\n", filename));
        output.push_str(&content);
        output.push('\n');
    }
    output
}

/// Map FieldType to Rust type.
fn field_type_to_rust(field_type: &FieldType, required: bool) -> String {
    let base = match field_type {
        FieldType::String => "String",
        FieldType::Number => "i64",
        FieldType::Boolean => "bool",
        FieldType::Date => "DateTimeUtc",
    };

    if required {
        base.to_string()
    } else {
        format!("Option<{}>", base)
    }
}

/// Capitalize the first letter of a string.
fn capitalize(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(c) => c.to_uppercase().collect::<String>() + chars.as_str(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use better_auth_core::db::schema::AuthSchema;

    #[test]
    fn test_generate_entities() {
        let schema = AuthSchema::core_schema();
        let entities = generate_entities(&schema);
        // Should have mod.rs + 4 tables (user, session, account, verification)
        assert!(entities.len() >= 5);

        // mod.rs should re-export all modules
        let mod_rs = &entities[0];
        assert_eq!(mod_rs.0, "mod.rs");
        assert!(mod_rs.1.contains("pub mod"));
    }

    #[test]
    fn test_entity_has_model() {
        let schema = AuthSchema::core_schema();
        let output = generate_all(&schema);
        assert!(output.contains("DeriveEntityModel"));
        assert!(output.contains("pub struct Model"));
    }

    #[test]
    fn test_entity_has_relations() {
        let schema = AuthSchema::core_schema();
        let output = generate_all(&schema);
        assert!(output.contains("DeriveRelation"));
        assert!(output.contains("pub enum Relation"));
    }

    #[test]
    fn test_entity_has_active_model() {
        let schema = AuthSchema::core_schema();
        let output = generate_all(&schema);
        assert!(output.contains("ActiveModelBehavior"));
    }

    #[test]
    fn test_field_type_mapping() {
        assert_eq!(field_type_to_rust(&FieldType::String, true), "String");
        assert_eq!(field_type_to_rust(&FieldType::String, false), "Option<String>");
        assert_eq!(field_type_to_rust(&FieldType::Number, true), "i64");
        assert_eq!(field_type_to_rust(&FieldType::Boolean, true), "bool");
        assert_eq!(field_type_to_rust(&FieldType::Date, true), "DateTimeUtc");
    }

    #[test]
    fn test_capitalize() {
        assert_eq!(capitalize("user"), "User");
        assert_eq!(capitalize("userId"), "UserId");
        assert_eq!(capitalize(""), "");
    }
}
