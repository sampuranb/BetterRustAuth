// Schema management — DDL generation and auto-migration from AuthSchema.
//
// Maps to: packages/better-auth/src/db/get-migration.ts
// Supports SQLite, PostgreSQL, MySQL, and MSSQL. Generates CREATE TABLE,
// ALTER TABLE, and CREATE INDEX statements. Full type mapping per database.

use sqlx::{AnyPool, Row};

use better_auth_core::db::adapter::{AdapterResult, SchemaOptions, SchemaStatus};
use better_auth_core::db::schema::{AuthSchema, FieldType, SchemaField};
use better_auth_core::error::BetterAuthError;

use crate::query_builder;

// ---------------------------------------------------------------------------
// Database type enum
// ---------------------------------------------------------------------------

/// Supported database types for DDL generation.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DatabaseType {
    Sqlite,
    Postgres,
    Mysql,
    Mssql,
}

impl DatabaseType {
    /// Parse from a string (case-insensitive).
    pub fn from_str(s: &str) -> Option<Self> {
        match s.to_lowercase().as_str() {
            "sqlite" => Some(Self::Sqlite),
            "postgres" | "postgresql" => Some(Self::Postgres),
            "mysql" | "mariadb" => Some(Self::Mysql),
            "mssql" | "sqlserver" => Some(Self::Mssql),
            _ => None,
        }
    }
}

impl Default for DatabaseType {
    fn default() -> Self {
        Self::Sqlite
    }
}

// ---------------------------------------------------------------------------
// ID generation strategy
// ---------------------------------------------------------------------------

/// ID generation strategy matching TS `advanced.database.generateId`.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum IdStrategy {
    #[default]
    NanoId,
    Uuid,
    Serial,
}

// ---------------------------------------------------------------------------
// Type maps — matching TS get-migration.ts postgresMap/mysqlMap/sqliteMap/mssqlMap
// ---------------------------------------------------------------------------

/// Check whether a SQL column type matches the expected field type for a given DB.
pub fn match_type(column_data_type: &str, field_type: &FieldType, db_type: DatabaseType) -> bool {
    let normalized = column_data_type.to_lowercase();
    let base = normalized.split('(').next().unwrap_or("").trim();

    let expected: &[&str] = match (db_type, field_type) {
        // Postgres
        (DatabaseType::Postgres, FieldType::String) => &["character varying", "varchar", "text", "uuid"],
        (DatabaseType::Postgres, FieldType::Number) => &["int4", "integer", "bigint", "smallint", "numeric", "real", "double precision"],
        (DatabaseType::Postgres, FieldType::Boolean) => &["bool", "boolean"],
        (DatabaseType::Postgres, FieldType::Date) => &["timestamptz", "timestamp", "date"],
        // MySQL
        (DatabaseType::Mysql, FieldType::String) => &["varchar", "text", "uuid"],
        (DatabaseType::Mysql, FieldType::Number) => &["integer", "int", "bigint", "smallint", "decimal", "float", "double"],
        (DatabaseType::Mysql, FieldType::Boolean) => &["boolean", "tinyint"],
        (DatabaseType::Mysql, FieldType::Date) => &["timestamp", "datetime", "date"],
        // SQLite
        (DatabaseType::Sqlite, FieldType::String) => &["text"],
        (DatabaseType::Sqlite, FieldType::Number) => &["integer", "real"],
        (DatabaseType::Sqlite, FieldType::Boolean) => &["integer", "boolean"],
        (DatabaseType::Sqlite, FieldType::Date) => &["date", "integer", "text"],
        // MSSQL
        (DatabaseType::Mssql, FieldType::String) => &["varchar", "nvarchar", "uniqueidentifier"],
        (DatabaseType::Mssql, FieldType::Number) => &["int", "bigint", "smallint", "decimal", "float", "double"],
        (DatabaseType::Mssql, FieldType::Boolean) => &["bit", "smallint"],
        (DatabaseType::Mssql, FieldType::Date) => &["datetime2", "date", "datetime"],
    };

    expected.iter().any(|e| base == *e)
}

// ---------------------------------------------------------------------------
// Column type for DDL generation
// ---------------------------------------------------------------------------

/// Get the database-specific column type for a field.
///
/// Matches the TS `getType()` function in `get-migration.ts`.
pub fn get_column_type(
    field: &SchemaField,
    field_name: &str,
    db_type: DatabaseType,
    id_strategy: IdStrategy,
) -> String {
    let is_id = field_name == "id";
    let is_fk = field.reference.is_some()
        && field.reference.as_ref().map(|r| r.field.as_str()) == Some("id");

    // ID column
    if is_id {
        return match (db_type, id_strategy) {
            (DatabaseType::Postgres, IdStrategy::Serial) => "integer GENERATED BY DEFAULT AS IDENTITY".into(),
            (DatabaseType::Postgres, IdStrategy::Uuid) => "uuid".into(),
            (DatabaseType::Postgres, _) => "text".into(),
            (DatabaseType::Mysql, IdStrategy::Serial) => "integer".into(),
            (DatabaseType::Mysql, _) => "varchar(36)".into(),
            (DatabaseType::Mssql, IdStrategy::Serial) => "integer".into(),
            (DatabaseType::Mssql, _) => "varchar(36)".into(),
            (DatabaseType::Sqlite, IdStrategy::Serial) => "integer".into(),
            (DatabaseType::Sqlite, _) => "text".into(),
        };
    }

    // Foreign key column referencing an ID
    if is_fk {
        return match (db_type, id_strategy) {
            (DatabaseType::Postgres, IdStrategy::Serial) => "integer".into(),
            (DatabaseType::Postgres, IdStrategy::Uuid) => "uuid".into(),
            (DatabaseType::Postgres, _) => "text".into(),
            (DatabaseType::Mysql, IdStrategy::Serial) => "integer".into(),
            (DatabaseType::Mysql, _) => "varchar(36)".into(),
            (DatabaseType::Mssql, IdStrategy::Serial) => "integer".into(),
            (DatabaseType::Mssql, _) => "varchar(36)".into(),
            (DatabaseType::Sqlite, IdStrategy::Serial) => "integer".into(),
            (DatabaseType::Sqlite, _) => "text".into(),
        };
    }

    // Regular fields
    match (&field.field_type, db_type) {
        // String
        (FieldType::String, DatabaseType::Sqlite) => "text".into(),
        (FieldType::String, DatabaseType::Postgres) => "text".into(),
        (FieldType::String, DatabaseType::Mysql) => {
            if field.unique || field.reference.is_some() {
                "varchar(255)".into()
            } else {
                "text".into()
            }
        }
        (FieldType::String, DatabaseType::Mssql) => {
            if field.unique {
                "varchar(255)".into()
            } else if field.reference.is_some() {
                "varchar(36)".into()
            } else {
                "varchar(8000)".into()
            }
        }
        // Boolean
        (FieldType::Boolean, DatabaseType::Sqlite) => "integer".into(),
        (FieldType::Boolean, DatabaseType::Postgres) => "boolean".into(),
        (FieldType::Boolean, DatabaseType::Mysql) => "boolean".into(),
        (FieldType::Boolean, DatabaseType::Mssql) => "smallint".into(),
        // Number
        (FieldType::Number, DatabaseType::Sqlite) => "integer".into(),
        (FieldType::Number, DatabaseType::Postgres) => "integer".into(),
        (FieldType::Number, DatabaseType::Mysql) => "integer".into(),
        (FieldType::Number, DatabaseType::Mssql) => "integer".into(),
        // Date
        (FieldType::Date, DatabaseType::Sqlite) => "text".into(),
        (FieldType::Date, DatabaseType::Postgres) => "timestamptz".into(),
        (FieldType::Date, DatabaseType::Mysql) => "timestamp(3)".into(),
        (FieldType::Date, DatabaseType::Mssql) => "datetime2(3)".into(),
    }
}

// ---------------------------------------------------------------------------
// DDL generation — full multi-DB support
// ---------------------------------------------------------------------------

/// Generate CREATE TABLE DDL from an AuthSchema for a given database type.
pub fn generate_ddl_for(
    schema: &AuthSchema,
    db_type: DatabaseType,
    id_strategy: IdStrategy,
) -> Vec<String> {
    let mut statements = Vec::new();

    for (table_name, table) in &schema.tables {
        let mut columns = Vec::new();

        // ID column first (if present)
        if table.fields.contains_key("id") {
            let id_type = get_column_type(
                table.fields.get("id").unwrap(),
                "id",
                db_type,
                id_strategy,
            );
            let mut id_def = format!(
                "{} {} PRIMARY KEY NOT NULL",
                query_builder::quote_identifier("id"),
                id_type
            );
            // Auto-increment for serial IDs
            if id_strategy == IdStrategy::Serial {
                match db_type {
                    DatabaseType::Mysql => id_def = format!(
                        "{} {} AUTO_INCREMENT PRIMARY KEY NOT NULL",
                        query_builder::quote_identifier("id"),
                        id_type
                    ),
                    DatabaseType::Mssql => id_def = format!(
                        "{} {} IDENTITY(1,1) PRIMARY KEY NOT NULL",
                        query_builder::quote_identifier("id"),
                        id_type
                    ),
                    _ => {} // Postgres uses GENERATED BY DEFAULT in the type itself
                }
            }
            // UUID default for Postgres
            if id_strategy == IdStrategy::Uuid && db_type == DatabaseType::Postgres {
                id_def = format!(
                    "{} {} DEFAULT pg_catalog.gen_random_uuid() PRIMARY KEY NOT NULL",
                    query_builder::quote_identifier("id"),
                    id_type
                );
            }
            columns.push(id_def);
        }

        // Other columns
        for (field_name, field) in &table.fields {
            if field_name == "id" {
                continue; // Already handled above
            }
            let col_type = get_column_type(field, field_name, db_type, id_strategy);
            let mut col_def = format!(
                "{} {}",
                query_builder::quote_identifier(field_name),
                col_type
            );

            if field.required {
                col_def.push_str(" NOT NULL");
            }

            if field.unique {
                col_def.push_str(" UNIQUE");
            }

            // Foreign key reference
            if let Some(ref fk) = field.reference {
                col_def.push_str(&format!(
                    " REFERENCES {}({}) ON DELETE {}",
                    query_builder::quote_identifier(&fk.table),
                    query_builder::quote_identifier(&fk.field),
                    fk.on_delete.as_deref().unwrap_or("CASCADE")
                ));
            }

            // Date defaults
            if field.field_type == FieldType::Date && field.default_value.is_some() {
                match db_type {
                    DatabaseType::Mysql => col_def.push_str(" DEFAULT CURRENT_TIMESTAMP(3)"),
                    DatabaseType::Postgres | DatabaseType::Mssql => {
                        col_def.push_str(" DEFAULT CURRENT_TIMESTAMP")
                    }
                    _ => {
                        if let Some(ref default) = field.default_value {
                            col_def.push_str(&format!(" DEFAULT {}", format_default(default)));
                        }
                    }
                }
            } else if let Some(ref default) = field.default_value {
                col_def.push_str(&format!(" DEFAULT {}", format_default(default)));
            }

            columns.push(col_def);
        }

        let create = format!(
            "CREATE TABLE IF NOT EXISTS {} (\n  {}\n)",
            query_builder::quote_identifier(table_name),
            columns.join(",\n  ")
        );

        statements.push(create);
    }

    statements
}

/// Generate CREATE INDEX statements for fields with `index: true`.
pub fn generate_index_ddl(schema: &AuthSchema) -> Vec<String> {
    let mut indexes = Vec::new();
    for (table_name, table) in &schema.tables {
        for (field_name, _field) in &table.fields {
            // Check if field has index attribute via the unique flag
            // (In the core schema, indexed fields are marked via attributes)
            // This generates indexes for unique fields
            if _field.unique && field_name != "id" {
                indexes.push(format!(
                    "CREATE UNIQUE INDEX IF NOT EXISTS {}_{}_uidx ON {} ({})",
                    table_name,
                    field_name,
                    query_builder::quote_identifier(table_name),
                    query_builder::quote_identifier(field_name)
                ));
            }
        }
    }
    indexes
}

/// Generate ALTER TABLE ADD COLUMN DDL for missing columns.
pub fn generate_alter_ddl(
    table_name: &str,
    field_name: &str,
    field: &SchemaField,
    db_type: DatabaseType,
    id_strategy: IdStrategy,
) -> String {
    let col_type = get_column_type(field, field_name, db_type, id_strategy);
    let mut alter = format!(
        "ALTER TABLE {} ADD COLUMN {} {}",
        query_builder::quote_identifier(table_name),
        query_builder::quote_identifier(field_name),
        col_type
    );

    if field.required {
        alter.push_str(" NOT NULL");
    }

    if field.unique {
        alter.push_str(" UNIQUE");
    }

    if let Some(ref fk) = field.reference {
        alter.push_str(&format!(
            " REFERENCES {}({}) ON DELETE {}",
            query_builder::quote_identifier(&fk.table),
            query_builder::quote_identifier(&fk.field),
            fk.on_delete.as_deref().unwrap_or("CASCADE")
        ));
    }

    if let Some(ref default) = field.default_value {
        alter.push_str(&format!(" DEFAULT {}", format_default(default)));
    }

    alter
}

/// Compile all migration statements into a single SQL string.
pub fn compile_migrations(statements: &[String]) -> String {
    if statements.is_empty() {
        return String::new();
    }
    statements.join(";\n\n") + ";"
}

// ---------------------------------------------------------------------------
// Legacy API (SQLite-only, kept for backward compatibility)
// ---------------------------------------------------------------------------

/// Generate CREATE TABLE DDL from an AuthSchema (SQLite).
pub fn generate_ddl(schema: &AuthSchema) -> Vec<String> {
    generate_ddl_for(schema, DatabaseType::Sqlite, IdStrategy::NanoId)
}

/// Convert a FieldType to a SQL type string (SQLite-compatible).
fn field_type_to_sql(field_type: &FieldType) -> &'static str {
    match field_type {
        FieldType::String => "TEXT",
        FieldType::Number => "INTEGER",
        FieldType::Boolean => "INTEGER",
        FieldType::Date => "TEXT",
    }
}

/// Format a default value for SQL.
fn format_default(value: &serde_json::Value) -> String {
    match value {
        serde_json::Value::String(s) => format!("'{}'", s.replace('\'', "''")),
        serde_json::Value::Number(n) => n.to_string(),
        serde_json::Value::Bool(b) => {
            if *b { "1".into() } else { "0".into() }
        }
        serde_json::Value::Null => "NULL".into(),
        _ => format!("'{}'", value),
    }
}

/// Create/migrate the schema in the database.
pub async fn create_schema(
    pool: &AnyPool,
    schema: &AuthSchema,
    options: &SchemaOptions,
) -> AdapterResult<SchemaStatus> {
    let ddl_statements = generate_ddl(schema);
    let mut migration_statements = Vec::new();

    for stmt in &ddl_statements {
        if options.auto_migrate {
            sqlx::query(stmt)
                .execute(pool)
                .await
                .map_err(|e| BetterAuthError::Other(format!("DDL execution failed: {e}")))?;
        }
        migration_statements.push(stmt.clone());
    }

    let alter_statements = check_missing_columns(pool, schema).await?;
    if !alter_statements.is_empty() {
        if options.auto_migrate {
            for stmt in &alter_statements {
                sqlx::query(stmt)
                    .execute(pool)
                    .await
                    .map_err(|e| {
                        BetterAuthError::Other(format!("ALTER execution failed: {e}"))
                    })?;
            }
        }
        migration_statements.extend(alter_statements);
    }

    if migration_statements.is_empty() {
        Ok(SchemaStatus::UpToDate)
    } else {
        Ok(SchemaStatus::NeedsMigration {
            statements: migration_statements,
        })
    }
}

/// Check for columns defined in the schema but missing from the database.
async fn check_missing_columns(
    pool: &AnyPool,
    schema: &AuthSchema,
) -> AdapterResult<Vec<String>> {
    let mut alter_stmts = Vec::new();

    for (table_name, table) in &schema.tables {
        let pragma_sql = format!("PRAGMA table_info({})", query_builder::quote_identifier(table_name));
        let rows = match sqlx::query(&pragma_sql).fetch_all(pool).await {
            Ok(rows) => rows,
            Err(_) => continue,
        };

        let existing_columns: Vec<String> = rows
            .iter()
            .filter_map(|row| row.try_get::<String, _>("name").ok())
            .collect();

        for (field_name, field) in &table.fields {
            if !existing_columns.contains(field_name) {
                let sql_type = field_type_to_sql(&field.field_type);
                let mut alter = format!(
                    "ALTER TABLE {} ADD COLUMN {} {}",
                    query_builder::quote_identifier(table_name),
                    query_builder::quote_identifier(field_name),
                    sql_type
                );

                if let Some(ref default) = field.default_value {
                    alter.push_str(&format!(" DEFAULT {}", format_default(default)));
                }

                alter_stmts.push(alter);
            }
        }
    }

    Ok(alter_stmts)
}

#[cfg(test)]
mod tests {
    use super::*;
    use better_auth_core::db::schema::AuthSchema;

    #[test]
    fn test_generate_ddl_core_schema() {
        let schema = AuthSchema::core_schema();
        let ddl = generate_ddl(&schema);
        assert!(ddl.len() >= 4, "Expected at least 4 tables, got {}", ddl.len());
        let user_ddl = ddl.iter().find(|s| s.contains("\"user\""));
        assert!(user_ddl.is_some(), "Missing user table DDL");
        let session_ddl = ddl.iter().find(|s| s.contains("\"session\""));
        assert!(session_ddl.is_some(), "Missing session table DDL");
    }

    #[test]
    fn test_field_type_mapping() {
        assert_eq!(field_type_to_sql(&FieldType::String), "TEXT");
        assert_eq!(field_type_to_sql(&FieldType::Number), "INTEGER");
        assert_eq!(field_type_to_sql(&FieldType::Boolean), "INTEGER");
        assert_eq!(field_type_to_sql(&FieldType::Date), "TEXT");
    }

    // -- New tests for multi-DB support --

    #[test]
    fn test_match_type_postgres() {
        assert!(match_type("varchar", &FieldType::String, DatabaseType::Postgres));
        assert!(match_type("text", &FieldType::String, DatabaseType::Postgres));
        assert!(match_type("boolean", &FieldType::Boolean, DatabaseType::Postgres));
        assert!(match_type("timestamptz", &FieldType::Date, DatabaseType::Postgres));
        assert!(!match_type("integer", &FieldType::String, DatabaseType::Postgres));
    }

    #[test]
    fn test_match_type_mysql() {
        assert!(match_type("varchar", &FieldType::String, DatabaseType::Mysql));
        assert!(match_type("tinyint", &FieldType::Boolean, DatabaseType::Mysql));
        assert!(match_type("timestamp", &FieldType::Date, DatabaseType::Mysql));
    }

    #[test]
    fn test_match_type_sqlite() {
        assert!(match_type("TEXT", &FieldType::String, DatabaseType::Sqlite));
        assert!(match_type("INTEGER", &FieldType::Number, DatabaseType::Sqlite));
        assert!(match_type("INTEGER", &FieldType::Boolean, DatabaseType::Sqlite));
    }

    #[test]
    fn test_match_type_mssql() {
        assert!(match_type("nvarchar", &FieldType::String, DatabaseType::Mssql));
        assert!(match_type("bit", &FieldType::Boolean, DatabaseType::Mssql));
        assert!(match_type("datetime2", &FieldType::Date, DatabaseType::Mssql));
    }

    #[test]
    fn test_get_column_type_id() {
        let field = SchemaField::required_string();
        assert_eq!(get_column_type(&field, "id", DatabaseType::Sqlite, IdStrategy::NanoId), "text");
        assert_eq!(get_column_type(&field, "id", DatabaseType::Postgres, IdStrategy::Uuid), "uuid");
        assert_eq!(get_column_type(&field, "id", DatabaseType::Mysql, IdStrategy::Serial), "integer");
    }

    #[test]
    fn test_get_column_type_string_mysql() {
        let field = SchemaField::required_string().with_unique();
        assert_eq!(get_column_type(&field, "email", DatabaseType::Mysql, IdStrategy::NanoId), "varchar(255)");
        let plain = SchemaField::required_string();
        assert_eq!(get_column_type(&plain, "name", DatabaseType::Mysql, IdStrategy::NanoId), "text");
    }

    #[test]
    fn test_get_column_type_date() {
        let field = SchemaField::created_at();
        assert_eq!(get_column_type(&field, "createdAt", DatabaseType::Postgres, IdStrategy::NanoId), "timestamptz");
        assert_eq!(get_column_type(&field, "createdAt", DatabaseType::Mysql, IdStrategy::NanoId), "timestamp(3)");
        assert_eq!(get_column_type(&field, "createdAt", DatabaseType::Mssql, IdStrategy::NanoId), "datetime2(3)");
    }

    #[test]
    fn test_generate_ddl_postgres() {
        let schema = AuthSchema::core_schema();
        let ddl = generate_ddl_for(&schema, DatabaseType::Postgres, IdStrategy::NanoId);
        assert!(ddl.len() >= 4);
        // Postgres should use "text" for string fields, "timestamptz" for dates
        let joined = ddl.join("\n");
        assert!(joined.contains("text"), "Expected text type in Postgres DDL");
    }

    #[test]
    fn test_compile_migrations() {
        let stmts = vec!["CREATE TABLE x (id text)".into(), "ALTER TABLE y ADD COLUMN z text".into()];
        let compiled = compile_migrations(&stmts);
        assert!(compiled.contains("CREATE TABLE x"));
        assert!(compiled.contains("ALTER TABLE y"));
        assert!(compiled.ends_with(';'));
    }

    #[test]
    fn test_generate_alter_ddl() {
        let field = SchemaField::optional_string();
        let alter = generate_alter_ddl("user", "bio", &field, DatabaseType::Postgres, IdStrategy::NanoId);
        assert!(alter.contains("ALTER TABLE"));
        assert!(alter.contains("\"bio\""));
        assert!(alter.contains("text"));
    }

    #[test]
    fn test_database_type_from_str() {
        assert_eq!(DatabaseType::from_str("postgres"), Some(DatabaseType::Postgres));
        assert_eq!(DatabaseType::from_str("PostgreSQL"), Some(DatabaseType::Postgres));
        assert_eq!(DatabaseType::from_str("mysql"), Some(DatabaseType::Mysql));
        assert_eq!(DatabaseType::from_str("sqlite"), Some(DatabaseType::Sqlite));
        assert_eq!(DatabaseType::from_str("mssql"), Some(DatabaseType::Mssql));
        assert_eq!(DatabaseType::from_str("unknown"), None);
    }
}
